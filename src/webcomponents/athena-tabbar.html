<dom-module id="athena-tabbar">

<link rel="import" href="athena-tab.html">

<template>

    <style>
        .outer {
            cursor: default;
            font-family: "Lucida Grande", "Lucida Sans Unicode", Verdana, Arial, Helvetica, sans-serif;
            font-size: 11px;
            line-height: 13px;
            transition : background 200ms;
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background : #cccccc;
            overflow: hidden;
        }
    </style>

    <div class="outer" on-mouseleave="_resizeTabs">
        <content id="tabs" select="athena-tab"></content>
    </div>

</template>

<script>
    Polymer({
        is: "athena-tabbar",

        properties: {
            selectedIndex: {
                type: Number,
                value: -1,
                notify: true,
                reflectToAttribute: true,
                observer: "_selectedIndexChanged"
            }
        },

        attached() {
            this._delayResizeTabs = false;
            this._observer = Polymer.dom(this.$.tabs).observeNodes(info => {
                if (info.addedNodes.length === info.removedNodes.length &&
                    info.addedNodes.every(tab => info.removedNodes.includes(tab))) {
                    // tabs were moved (Polymer may move a different set than you expect, too)
                    return;
                }

                this._updateTabListeners(info.removedNodes, this.unlisten.bind(this));
                this._updateTabListeners(info.addedNodes, this.listen.bind(this));

                const tabs = this.getEffectiveChildren();

                if (info.addedNodes.length > 0) {
                    this._activateTab(info.addedNodes[info.addedNodes.length - 1]);
                } else if (this.selectedIndex >= tabs.length) {
                    this._activateTab(tabs[tabs.length - 1]);
                } else if (this.selectedIndex !== -1) {
                    this._activateTab(tabs[this.selectedIndex]);
                }

                if (info.addedNodes.length > 0 || !this._delayResizeTabs) {
                    this._resizeTabs();
                }
                this._delayResizeTabs = false;
            });
        },

        detached() {
            this._updateTabListeners(this.getEffectiveChildren(), this.unlisten.bind(this));
            Polymer.dom(this.$.tabs).unobserveNodes(this._observer);
            this._observer = null;
        },

        _updateTabListeners(tabs, listenFn) {
            for (let tab of tabs) {
                listenFn(tab, "click-tab", "_clickTab");
                listenFn(tab, "close-tab", "_closeTab");
                listenFn(tab, "transitionend", "_transitionEnd");
                listenFn(tab, "track", "_dragTab");
            }
        },

        _selectedIndexChanged(selectedIndex) {
            const index = Number(selectedIndex);
            const tabs = this.getEffectiveChildren();
            for (let i = 0; i < tabs.length; ++i) {
                tabs[i].active = (i === index);
            }
        },

        _activateTab(tab) {
            if (this._fireTabEvent("activate-tab", tab)) {
                const tabs = this.getEffectiveChildren();
                this.selectedIndex = tabs.findIndex(t => t === tab);
                this._selectedIndexChanged(this.selectedIndex);
                return true;
            }
            return false;
        },

        _clickTab(event) {
            event.stopPropagation();
            this._activateTab(event.currentTarget);
        },

        _closeTab(event) {
            event.stopPropagation();
            const tab = event.currentTarget;
            if (this._fireTabEvent("close-tab", tab)) {
                this._delayResizeTabs = (tab.nextSibling !== null);
                if (this._delayResizeTabs) {
                    tab.width = "0";
                } else {
                    Polymer.dom(this).removeChild(tab);
                }
            }
        },

        _fireTabEvent(eventName, tab) {
            let event = this.fire(eventName, {tab: tab}, {cancelable: true});
            return !event.defaultPrevented;
        },

        _resizeTabs() {
            const tabs = this.getEffectiveChildren();
            const width = `${100/tabs.length}%`;
            for (let i = 0; i < tabs.length; ++i) {
                tabs[i].width = width;
            }
        },

        _transitionEnd(event) {
            if (event.propertyName === "width") {
                const tab = event.target;
                if (tab.width === "0") {
                    if (this._delayResizeTabs) {
                        this.removeChild(tab);
                    }
                }
            }
        },

        _dragTab(event) {
            const tabs = this.getEffectiveChildren();
            if (event.detail.state === "start") {
                this._dragTabStart(tabs, event.target);
            } else if (this._draggedTabIndex !== -1) {
                if (event.detail.state === "track") {
                    this._dragTabTrack(tabs, event.detail);
                } else if (event.detail.state === "end") {
                    this._dragTabEnd(tabs);
                }
            }
        },

        _dragTabStart(tabs, tab) {
            this._draggedTabIndex = tabs.findIndex(t => t === tab);
            if (this._draggedTabIndex !== -1) {
                if (!this._activateTab(tab)) {
                    this._draggedTabIndex = -1;
                }
            }
        },

        _dragTabTrack(tabs, track) {
            const bounds = this.$$(".outer").getBoundingClientRect();
            const tabWidth = bounds.width / tabs.length;

            if (event.detail.x < bounds.left) {
                this._droppedTabIndex = 0;
            } else if (bounds.right <= track.x) {
                this._droppedTabIndex = tabs.length - 1;
            } else {
                this._droppedTabIndex = Math.floor((track.x - bounds.left) / tabWidth);
            }

            for (let i = 0; i < tabs.length; ++i) {
                let width;
                if (i < this._draggedTabIndex) {
                    width = (i < this._droppedTabIndex) ? 0 : tabWidth;
                } else if (i > this._draggedTabIndex) {
                    width = (i > this._droppedTabIndex) ? 0 : -tabWidth;
                } else {
                    width = track.dx;
                }
                tabs[i].hOffset = width;
            }
        },

        _dragTabEnd(tabs) {
            for (let i = 0; i < tabs.length; ++i) {
                tabs[i].hOffset = 0;
            }

            if (this._draggedTabIndex !== this._droppedTabIndex) {
                let dragTab = tabs[this._draggedTabIndex];
                let dropTab = tabs[this._droppedTabIndex];

                if (this._draggedTabIndex < this._droppedTabIndex) {
                    dropTab = Polymer.dom(dropTab).nextSibling;
                }

                Polymer.dom(this).insertBefore(dragTab, dropTab);
            }
            
            this.selectedIndex = this._droppedTabIndex;
            this._draggedTabIndex = -1;
            this._droppedTabIndex = -1;
        }
    });
</script>

</dom-module>